diff --git a/drivers/net/tap/rte_eth_tap.c b/drivers/net/tap/rte_eth_tap.c
index 1bc8ae51cf6b..730f1859bd28 100644
--- a/drivers/net/tap/rte_eth_tap.c
+++ b/drivers/net/tap/rte_eth_tap.c
@@ -22,9 +22,7 @@
 #include <assert.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/socket.h>
 #include <sys/ioctl.h>
-#include <sys/utsname.h>
 #include <sys/mman.h>
 #include <errno.h>
 #include <signal.h>
@@ -33,12 +31,10 @@
 #include <stdlib.h>
 #include <sys/uio.h>
 #include <unistd.h>
-#include <arpa/inet.h>
 #include <net/if.h>
 #include <linux/if_tun.h>
-#include <linux/if_ether.h>
+#include <linux/sched.h>
 #include <fcntl.h>
-#include <ctype.h>
 
 #include <tap_rss.h>
 #include <rte_eth_tap.h>
@@ -116,13 +112,6 @@ tap_trigger_cb(int sig __rte_unused)
 	tap_trigger = (tap_trigger + 1) | 0x80000000;
 }
 
-/* Specifies on what netdevices the ioctl should be applied */
-enum ioctl_mode {
-	LOCAL_AND_REMOTE,
-	LOCAL_ONLY,
-	REMOTE_ONLY,
-};
-
 /* Message header to synchronize queues via IPC */
 struct ipc_queues {
 	char port_name[RTE_DEV_NAME_MAX_LEN];
@@ -756,93 +745,28 @@ pmd_tx_burst(void *queue, struct rte_mbuf **bufs, uint16_t nb_pkts)
 	return num_tx;
 }
 
-static const char *
-tap_ioctl_req2str(unsigned long request)
-{
-	switch (request) {
-	case SIOCSIFFLAGS:
-		return "SIOCSIFFLAGS";
-	case SIOCGIFFLAGS:
-		return "SIOCGIFFLAGS";
-	case SIOCGIFHWADDR:
-		return "SIOCGIFHWADDR";
-	case SIOCSIFHWADDR:
-		return "SIOCSIFHWADDR";
-	case SIOCSIFMTU:
-		return "SIOCSIFMTU";
-	}
-	return "UNKNOWN";
-}
-
-static int
-tap_ioctl(struct pmd_internals *pmd, unsigned long request,
-	  struct ifreq *ifr, int set, enum ioctl_mode mode)
-{
-	short req_flags = ifr->ifr_flags;
-	int remote = pmd->remote_if_index &&
-		(mode == REMOTE_ONLY || mode == LOCAL_AND_REMOTE);
-
-	if (!pmd->remote_if_index && mode == REMOTE_ONLY)
-		return 0;
-	/*
-	 * If there is a remote netdevice, apply ioctl on it, then apply it on
-	 * the tap netdevice.
-	 */
-apply:
-	if (remote)
-		strlcpy(ifr->ifr_name, pmd->remote_iface, IFNAMSIZ);
-	else if (mode == LOCAL_ONLY || mode == LOCAL_AND_REMOTE)
-		strlcpy(ifr->ifr_name, pmd->name, IFNAMSIZ);
-	switch (request) {
-	case SIOCSIFFLAGS:
-		/* fetch current flags to leave other flags untouched */
-		if (ioctl(pmd->ioctl_sock, SIOCGIFFLAGS, ifr) < 0)
-			goto error;
-		if (set)
-			ifr->ifr_flags |= req_flags;
-		else
-			ifr->ifr_flags &= ~req_flags;
-		break;
-	case SIOCGIFFLAGS:
-	case SIOCGIFHWADDR:
-	case SIOCSIFHWADDR:
-	case SIOCSIFMTU:
-		break;
-	default:
-		TAP_LOG(WARNING, "%s: ioctl() called with wrong arg",
-			pmd->name);
-		return -EINVAL;
-	}
-	if (ioctl(pmd->ioctl_sock, request, ifr) < 0)
-		goto error;
-	if (remote-- && mode == LOCAL_AND_REMOTE)
-		goto apply;
-	return 0;
-
-error:
-	TAP_LOG(DEBUG, "%s(%s) failed: %s(%d)", ifr->ifr_name,
-		tap_ioctl_req2str(request), strerror(errno), errno);
-	return -errno;
-}
-
 static int
 tap_link_set_down(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_UP };
 
 	dev->data->dev_link.link_status = RTE_ETH_LINK_DOWN;
-	return tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 0, LOCAL_ONLY);
+	return tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_UP, 0);
 }
 
 static int
 tap_link_set_up(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_UP };
+	int ret;
 
 	dev->data->dev_link.link_status = RTE_ETH_LINK_UP;
-	return tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 1, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_UP, 1);
+	if (ret < 0)
+		return ret;
+	if (pmd->remote_if_index)
+		return tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index, IFF_UP, 1);
+	return 0;
 }
 
 static int
@@ -1131,8 +1055,6 @@ tap_dev_close(struct rte_eth_dev *dev)
 	if (internals->nlsk_fd != -1) {
 		tap_flow_flush(dev, NULL);
 		tap_flow_implicit_flush(internals, NULL);
-		tap_nl_final(internals->nlsk_fd);
-		internals->nlsk_fd = -1;
 		tap_flow_bpf_destroy(internals);
 	}
 #endif
@@ -1150,11 +1072,10 @@ tap_dev_close(struct rte_eth_dev *dev)
 
 	if (internals->remote_if_index) {
 		/* Restore initial remote state */
-		int ret = ioctl(internals->ioctl_sock, SIOCSIFFLAGS,
-				&internals->remote_initial_flags);
+		int ret = tap_nl_set_flags(internals->nlsk_fd, internals->remote_if_index,
+					   internals->remote_initial_flags, 1);
 		if (ret)
 			TAP_LOG(ERR, "restore remote state failed: %d", ret);
-
 	}
 
 	rte_mempool_free(internals->gso_ctx_mp);
@@ -1174,9 +1095,9 @@ tap_dev_close(struct rte_eth_dev *dev)
 
 	rte_intr_instance_free(internals->intr_handle);
 
-	if (internals->ioctl_sock != -1) {
-		close(internals->ioctl_sock);
-		internals->ioctl_sock = -1;
+	if (internals->nlsk_fd != -1) {
+		tap_nl_final(internals->nlsk_fd);
+		internals->nlsk_fd = -1;
 	}
 	free(dev->process_private);
 	dev->process_private = NULL;
@@ -1231,21 +1152,22 @@ tap_link_update(struct rte_eth_dev *dev, int wait_to_complete __rte_unused)
 {
 	struct rte_eth_link *dev_link = &dev->data->dev_link;
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = 0 };
+	unsigned int flags = 0;
 
 	if (pmd->remote_if_index) {
-		tap_ioctl(pmd, SIOCGIFFLAGS, &ifr, 0, REMOTE_ONLY);
-		if (!(ifr.ifr_flags & IFF_UP) ||
-		    !(ifr.ifr_flags & IFF_RUNNING)) {
-			dev_link->link_status = RTE_ETH_LINK_DOWN;
-			return 0;
+		if (tap_nl_get_flags(pmd->nlsk_fd, pmd->remote_if_index, &flags) == 0) {
+			if (!(flags & IFF_UP) || !(flags & IFF_RUNNING)) {
+				dev_link->link_status = RTE_ETH_LINK_DOWN;
+				return 0;
+			}
 		}
 	}
-	tap_ioctl(pmd, SIOCGIFFLAGS, &ifr, 0, LOCAL_ONLY);
-	dev_link->link_status =
-		((ifr.ifr_flags & IFF_UP) && (ifr.ifr_flags & IFF_RUNNING) ?
-		 RTE_ETH_LINK_UP :
-		 RTE_ETH_LINK_DOWN);
+	if (tap_nl_get_flags(pmd->nlsk_fd, pmd->if_index, &flags) == 0) {
+		if ((flags & IFF_UP) && (flags & IFF_RUNNING))
+			dev_link->link_status = RTE_ETH_LINK_UP;
+		else
+			dev_link->link_status = RTE_ETH_LINK_DOWN;
+	}
 	return 0;
 }
 
@@ -1253,20 +1175,28 @@ static int
 tap_promisc_enable(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_PROMISC };
 	int ret;
 
-	ret = tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 1, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_PROMISC, 1);
 	if (ret != 0)
 		return ret;
 
+	if (pmd->remote_if_index) {
+		ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index, IFF_PROMISC, 1);
+		if (ret != 0)
+			return ret;
+	}
+
 #ifdef HAVE_TCA_FLOWER
 	if (pmd->remote_if_index && !pmd->flow_isolate) {
 		dev->data->promiscuous = 1;
 		ret = tap_flow_implicit_create(pmd, TAP_REMOTE_PROMISC);
 		if (ret != 0) {
 			/* Rollback promisc flag */
-			tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 0, LOCAL_AND_REMOTE);
+			tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_PROMISC, 0);
+			if (pmd->remote_if_index)
+				tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index,
+						 IFF_PROMISC, 0);
 			/*
 			 * rte_eth_dev_promiscuous_enable() rollback
 			 * dev->data->promiscuous in the case of failure.
@@ -1282,20 +1212,28 @@ static int
 tap_promisc_disable(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_PROMISC };
 	int ret;
 
-	ret = tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 0, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_PROMISC, 0);
 	if (ret != 0)
 		return ret;
 
+	if (pmd->remote_if_index) {
+		ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index, IFF_PROMISC, 0);
+		if (ret != 0)
+			return ret;
+	}
+
 #ifdef HAVE_TCA_FLOWER
 	if (pmd->remote_if_index && !pmd->flow_isolate) {
 		dev->data->promiscuous = 0;
 		ret = tap_flow_implicit_destroy(pmd, TAP_REMOTE_PROMISC);
 		if (ret != 0) {
 			/* Rollback promisc flag */
-			tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 1, LOCAL_AND_REMOTE);
+			tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_PROMISC, 1);
+			if (pmd->remote_if_index)
+				tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index,
+						 IFF_PROMISC, 1);
 			/*
 			 * rte_eth_dev_promiscuous_disable() rollback
 			 * dev->data->promiscuous in the case of failure.
@@ -1312,20 +1250,28 @@ static int
 tap_allmulti_enable(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_ALLMULTI };
 	int ret;
 
-	ret = tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 1, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_ALLMULTI, 1);
 	if (ret != 0)
 		return ret;
 
+	if (pmd->remote_if_index) {
+		ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index, IFF_ALLMULTI, 1);
+		if (ret != 0)
+			return ret;
+	}
+
 #ifdef HAVE_TCA_FLOWER
 	if (pmd->remote_if_index && !pmd->flow_isolate) {
 		dev->data->all_multicast = 1;
 		ret = tap_flow_implicit_create(pmd, TAP_REMOTE_ALLMULTI);
 		if (ret != 0) {
 			/* Rollback allmulti flag */
-			tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 0, LOCAL_AND_REMOTE);
+			tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_ALLMULTI, 0);
+			if (pmd->remote_if_index)
+				tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index,
+						 IFF_ALLMULTI, 0);
 			/*
 			 * rte_eth_dev_allmulticast_enable() rollback
 			 * dev->data->all_multicast in the case of failure.
@@ -1342,20 +1288,28 @@ static int
 tap_allmulti_disable(struct rte_eth_dev *dev)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_flags = IFF_ALLMULTI };
 	int ret;
 
-	ret = tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 0, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_ALLMULTI, 0);
 	if (ret != 0)
 		return ret;
 
+	if (pmd->remote_if_index) {
+		ret = tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index, IFF_ALLMULTI, 0);
+		if (ret != 0)
+			return ret;
+	}
+
 #ifdef HAVE_TCA_FLOWER
 	if (pmd->remote_if_index && !pmd->flow_isolate) {
 		dev->data->all_multicast = 0;
 		ret = tap_flow_implicit_destroy(pmd, TAP_REMOTE_ALLMULTI);
 		if (ret != 0) {
 			/* Rollback allmulti flag */
-			tap_ioctl(pmd, SIOCSIFFLAGS, &ifr, 1, LOCAL_AND_REMOTE);
+			tap_nl_set_flags(pmd->nlsk_fd, pmd->if_index, IFF_ALLMULTI, 1);
+			if (pmd->remote_if_index)
+				tap_nl_set_flags(pmd->nlsk_fd, pmd->remote_if_index,
+						 IFF_ALLMULTI, 1);
 			/*
 			 * rte_eth_dev_allmulticast_disable() rollback
 			 * dev->data->all_multicast in the case of failure.
@@ -1372,8 +1326,8 @@ static int
 tap_mac_set(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	enum ioctl_mode mode = LOCAL_ONLY;
-	struct ifreq ifr;
+	struct rte_ether_addr current_mac;
+	bool set_remote = false;
 	int ret;
 
 	if (pmd->type == ETH_TUNTAP_TYPE_TUN) {
@@ -1388,28 +1342,31 @@ tap_mac_set(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr)
 		return -EINVAL;
 	}
 	/* Check the actual current MAC address on the tap netdevice */
-	ret = tap_ioctl(pmd, SIOCGIFHWADDR, &ifr, 0, LOCAL_ONLY);
+	ret = tap_nl_get_mac(pmd->nlsk_fd, pmd->if_index, &current_mac);
 	if (ret < 0)
 		return ret;
-	if (rte_is_same_ether_addr(
-			(struct rte_ether_addr *)&ifr.ifr_hwaddr.sa_data,
-			mac_addr))
+	if (rte_is_same_ether_addr(&current_mac, mac_addr))
 		return 0;
-	/* Check the current MAC address on the remote */
-	ret = tap_ioctl(pmd, SIOCGIFHWADDR, &ifr, 0, REMOTE_ONLY);
-	if (ret < 0)
-		return ret;
-	if (!rte_is_same_ether_addr(
-			(struct rte_ether_addr *)&ifr.ifr_hwaddr.sa_data,
-			mac_addr))
-		mode = LOCAL_AND_REMOTE;
-	ifr.ifr_hwaddr.sa_family = AF_LOCAL;
 
-	rte_ether_addr_copy(mac_addr, (struct rte_ether_addr *)&ifr.ifr_hwaddr.sa_data);
-	ret = tap_ioctl(pmd, SIOCSIFHWADDR, &ifr, 1, mode);
+	/* Check the current MAC address on the remote */
+	if (pmd->remote_if_index) {
+		ret = tap_nl_get_mac(pmd->nlsk_fd, pmd->remote_if_index, &current_mac);
+		if (ret < 0)
+			return ret;
+		if (!rte_is_same_ether_addr(&current_mac, mac_addr))
+			set_remote = true;
+	}
+
+	ret = tap_nl_set_mac(pmd->nlsk_fd, pmd->if_index, mac_addr);
 	if (ret < 0)
 		return ret;
 
+	if (set_remote) {
+		ret = tap_nl_set_mac(pmd->nlsk_fd, pmd->remote_if_index, mac_addr);
+		if (ret < 0)
+			return ret;
+	}
+
 	rte_ether_addr_copy(mac_addr, &pmd->eth_addr);
 
 #ifdef HAVE_TCA_FLOWER
@@ -1435,6 +1392,22 @@ tap_mac_set(struct rte_eth_dev *dev, struct rte_ether_addr *mac_addr)
 	return 0;
 }
 
+static int tap_carrier_set(struct pmd_internals *pmd, int carrier)
+{
+#ifdef TUNSETCARRIER
+	int ret = ioctl(pmd->ka_fd, TUNSETCARRIER, &carrier);
+	if (ret < 0) {
+		TAP_LOG(ERR, "%s: ioctl(TUNSETCARRIER) failed: %s",
+			pmd->name, strerror(errno));
+		return ret;
+	}
+#else
+	(void)pmd;
+	(void)carrier;
+#endif
+	return 0;
+}
+
 static int
 tap_gso_ctx_setup(struct rte_gso_ctx *gso_ctx, struct rte_eth_dev *dev)
 {
@@ -1602,6 +1575,11 @@ tap_rx_queue_setup(struct rte_eth_dev *dev,
 		tmp = &(*tmp)->next;
 	}
 
+	/* set carrier after creating at least one rxq */
+	ret = tap_carrier_set(internals, 1);
+	if (ret < 0)
+		goto error;
+
 	TAP_LOG(DEBUG, "  RX TUNTAP device name %s, qid %d on fd %d",
 		internals->name, rx_queue_id,
 		process_private->fds[rx_queue_id]);
@@ -1658,9 +1636,16 @@ static int
 tap_mtu_set(struct rte_eth_dev *dev, uint16_t mtu)
 {
 	struct pmd_internals *pmd = dev->data->dev_private;
-	struct ifreq ifr = { .ifr_mtu = mtu };
+	int ret;
 
-	return tap_ioctl(pmd, SIOCSIFMTU, &ifr, 1, LOCAL_AND_REMOTE);
+	ret = tap_nl_set_mtu(pmd->nlsk_fd, pmd->if_index, mtu);
+	if (ret < 0)
+		return ret;
+
+	if (pmd->remote_if_index)
+		return tap_nl_set_mtu(pmd->nlsk_fd, pmd->remote_if_index, mtu);
+
+	return 0;
 }
 
 static int
@@ -1675,17 +1660,122 @@ tap_set_mc_addr_list(struct rte_eth_dev *dev __rte_unused,
 	return 0;
 }
 
+static void tap_dev_intr_handler(void *cb_arg);
+static int tap_lsc_intr_handle_set(struct rte_eth_dev *dev, int set);
+
+static int
+tap_netns_change(struct rte_eth_dev *dev)
+{
+	struct pmd_internals *pmd = dev->data->dev_private;
+#ifdef TUNGETDEVNETNS
+	int netns_fd, orig_netns_fd, new_nlsk_fd;
+
+	netns_fd = ioctl(pmd->ka_fd, TUNGETDEVNETNS);
+	if (netns_fd < 0) {
+		TAP_LOG(INFO, "%s: interface deleted", pmd->name);
+		return 0;
+	}
+
+	/* Interface was moved to another namespace */
+	pmd->if_index = 0;
+
+	/* Save current namespace */
+	orig_netns_fd = open("/proc/self/ns/net", O_RDONLY);
+	if (orig_netns_fd < 0) {
+		TAP_LOG(ERR, "%s: failed to open original netns: %s",
+			pmd->name, strerror(errno));
+		close(netns_fd);
+		return -1;
+	}
+
+	/* Switch to new namespace */
+	if (setns(netns_fd, CLONE_NEWNET) < 0) {
+		TAP_LOG(ERR, "%s: failed to enter new netns: %s",
+			pmd->name, strerror(errno));
+		close(netns_fd);
+		close(orig_netns_fd);
+		return -1;
+	}
+
+	/*
+	 * Update ifindex by querying interface name.
+	 * The interface now has a new ifindex in the new namespace.
+	 */
+	pmd->if_index = if_nametoindex(pmd->name);
+
+	/* Recreate netlink socket in new namespace */
+	new_nlsk_fd = tap_nl_init(0);
+
+	/* Recreate LSC interrupt netlink socket in new namespace */
+	rte_intr_callback_unregister_pending(pmd->intr_handle, tap_dev_intr_handler, dev, NULL);
+	if (tap_lsc_intr_handle_set(dev, 1) < 0)
+		TAP_LOG(WARNING, "%s: failed to recreate LSC interrupt socket",
+			pmd->name);
+
+	/* Force carrier back after switching netns */
+	tap_carrier_set(pmd, 1);
+
+	/* Switch back to original namespace */
+	if (setns(orig_netns_fd, CLONE_NEWNET) < 0)
+		TAP_LOG(ERR, "%s: failed to return to original netns: %s",
+			pmd->name, strerror(errno));
+
+	close(orig_netns_fd);
+	close(netns_fd);
+
+	if (pmd->if_index == 0) {
+		TAP_LOG(WARNING, "%s: interface moved to another namespace, "
+			"failed to get new ifindex",
+			pmd->name);
+		if (new_nlsk_fd >= 0)
+			close(new_nlsk_fd);
+		return -1;
+	}
+
+	if (new_nlsk_fd < 0) {
+		TAP_LOG(WARNING, "%s: failed to recreate netlink socket in new namespace",
+			pmd->name);
+		return -1;
+	}
+
+	/* Close old netlink socket and replace with new one */
+	if (pmd->nlsk_fd >= 0)
+		tap_nl_final(pmd->nlsk_fd);
+	pmd->nlsk_fd = new_nlsk_fd;
+
+	TAP_LOG(INFO, "%s: interface moved to another namespace, new ifindex: %u",
+		pmd->name, pmd->if_index);
+#else
+	TAP_LOG(WARNING, "%s: interface deleted or moved to another namespace",
+		pmd->name);
+#endif
+
+	return 0;
+}
+
 static int
 tap_nl_msg_handler(struct nlmsghdr *nh, void *arg)
 {
 	struct rte_eth_dev *dev = arg;
 	struct pmd_internals *pmd = dev->data->dev_private;
 	struct ifinfomsg *info = NLMSG_DATA(nh);
+	int is_local = (info->ifi_index == pmd->if_index);
+	int is_remote = (info->ifi_index == pmd->remote_if_index);
 
-	if (nh->nlmsg_type != RTM_NEWLINK ||
-	    (info->ifi_index != pmd->if_index &&
-	     info->ifi_index != pmd->remote_if_index))
+	/* Ignore messages not for our interfaces */
+	if (!is_local && !is_remote)
 		return 0;
+
+	if (nh->nlmsg_type == RTM_DELLINK && is_local) {
+		/*
+		 * RTM_DELLINK may indicate the interface was moved to another
+		 * network namespace. Check if the device still exists by
+		 * querying its namespace via the keep-alive fd.
+		 */
+		int ret = tap_netns_change(dev);
+		if (ret < 0)
+			return ret;
+	}
 	return tap_link_update(dev, 0);
 }
 
@@ -1714,6 +1804,12 @@ tap_lsc_intr_handle_set(struct rte_eth_dev *dev, int set)
 		return 0;
 	}
 	if (set) {
+		/*
+		 * Subscribe to RTMGRP_LINK to receive RTM_NEWLINK (link state
+		 * changes) events. Also receives RTM_DELLINK events which are
+		 * used for namespace change detection when TUNGETDEVNETNS is
+		 * available.
+		 */
 		rte_intr_fd_set(pmd->intr_handle, tap_nl_init(RTMGRP_LINK));
 		if (unlikely(rte_intr_fd_get(pmd->intr_handle) == -1))
 			return -EBADF;
@@ -1921,7 +2017,6 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 	struct pmd_process_private *process_private;
 	const char *tuntap_name = tuntap_types[type];
 	struct rte_eth_dev_data *data;
-	struct ifreq ifr;
 	int i;
 
 	TAP_LOG(DEBUG, "%s device on numa %u", tuntap_name, rte_socket_id());
@@ -1946,20 +2041,9 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 	strlcpy(pmd->name, tap_name, sizeof(pmd->name));
 	pmd->type = type;
 	pmd->ka_fd = -1;
-
-#ifdef HAVE_TCA_FLOWER
 	pmd->nlsk_fd = -1;
-#endif
 	pmd->gso_ctx_mp = NULL;
 
-	pmd->ioctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
-	if (pmd->ioctl_sock == -1) {
-		TAP_LOG(ERR,
-			"%s Unable to get a socket for management: %s",
-			tuntap_name, strerror(errno));
-		goto error_exit;
-	}
-
 	/* Allocate interrupt instance */
 	pmd->intr_handle = rte_intr_instance_alloc(RTE_INTR_INSTANCE_F_SHARED);
 	if (pmd->intr_handle == NULL) {
@@ -2013,15 +2097,27 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 	}
 	TAP_LOG(DEBUG, "allocated %s", pmd->name);
 
-	ifr.ifr_mtu = dev->data->mtu;
-	if (tap_ioctl(pmd, SIOCSIFMTU, &ifr, 1, LOCAL_AND_REMOTE) < 0)
+	/*
+	 * Create netlink socket for interface control.
+	 * Netlink provides ifindex-based operations and is namespace-safe.
+	 */
+	pmd->nlsk_fd = tap_nl_init(0);
+	if (pmd->nlsk_fd == -1) {
+		TAP_LOG(ERR, "%s: failed to create netlink socket.", pmd->name);
+		goto error_exit;
+	}
+
+	pmd->if_index = if_nametoindex(pmd->name);
+	if (!pmd->if_index) {
+		TAP_LOG(ERR, "%s: failed to get if_index.", pmd->name);
+		goto error_exit;
+	}
+
+	if (tap_nl_set_mtu(pmd->nlsk_fd, pmd->if_index, dev->data->mtu) < 0)
 		goto error_exit;
 
 	if (pmd->type == ETH_TUNTAP_TYPE_TAP) {
-		memset(&ifr, 0, sizeof(struct ifreq));
-		ifr.ifr_hwaddr.sa_family = AF_LOCAL;
-		rte_ether_addr_copy(&pmd->eth_addr, (struct rte_ether_addr *)&ifr.ifr_hwaddr.sa_data);
-		if (tap_ioctl(pmd, SIOCSIFHWADDR, &ifr, 0, LOCAL_ONLY) < 0)
+		if (tap_nl_set_mac(pmd->nlsk_fd, pmd->if_index, &pmd->eth_addr) < 0)
 			goto error_exit;
 	}
 
@@ -2031,23 +2127,10 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 #ifdef HAVE_TCA_FLOWER
 	/*
 	 * Set up everything related to rte_flow:
-	 * - netlink socket
-	 * - tap / remote if_index
 	 * - mandatory QDISCs
 	 * - rte_flow actual/implicit lists
 	 * - implicit rules
 	 */
-	pmd->nlsk_fd = tap_nl_init(0);
-	if (pmd->nlsk_fd == -1) {
-		TAP_LOG(WARNING, "%s: failed to create netlink socket.",
-			pmd->name);
-		goto disable_rte_flow;
-	}
-	pmd->if_index = if_nametoindex(pmd->name);
-	if (!pmd->if_index) {
-		TAP_LOG(ERR, "%s: failed to get if_index.", pmd->name);
-		goto disable_rte_flow;
-	}
 	if (qdisc_create_multiq(pmd->nlsk_fd, pmd->if_index) < 0) {
 		TAP_LOG(ERR, "%s: failed to create multiq qdisc.",
 			pmd->name);
@@ -2071,19 +2154,19 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 		strlcpy(pmd->remote_iface, remote_iface, RTE_ETH_NAME_MAX_LEN);
 
 		/* Save state of remote device */
-		tap_ioctl(pmd, SIOCGIFFLAGS, &pmd->remote_initial_flags, 0, REMOTE_ONLY);
+		if (tap_nl_get_flags(pmd->nlsk_fd, pmd->remote_if_index,
+					  &pmd->remote_initial_flags) < 0)
+			pmd->remote_initial_flags = 0;
 
 		/* Replicate remote MAC address */
-		if (tap_ioctl(pmd, SIOCGIFHWADDR, &ifr, 0, REMOTE_ONLY) < 0) {
+		if (tap_nl_get_mac(pmd->nlsk_fd, pmd->remote_if_index, &pmd->eth_addr) < 0) {
 			TAP_LOG(ERR, "%s: failed to get %s MAC address.",
 				pmd->name, pmd->remote_iface);
 			goto error_remote;
 		}
 
-		rte_ether_addr_copy((struct rte_ether_addr *)&ifr.ifr_hwaddr.sa_data, &pmd->eth_addr);
-		/* The desired MAC is already in ifreq after SIOCGIFHWADDR. */
-		if (tap_ioctl(pmd, SIOCSIFHWADDR, &ifr, 0, LOCAL_ONLY) < 0) {
-			TAP_LOG(ERR, "%s: failed to get %s MAC address.",
+		if (tap_nl_set_mac(pmd->nlsk_fd, pmd->if_index, &pmd->eth_addr) < 0) {
+			TAP_LOG(ERR, "%s: failed to set %s MAC address.",
 				pmd->name, remote_iface);
 			goto error_remote;
 		}
@@ -2134,14 +2217,10 @@ eth_dev_tap_create(struct rte_vdev_device *vdev, const char *tap_name,
 #endif
 
 error_exit:
-#ifdef HAVE_TCA_FLOWER
 	if (pmd->nlsk_fd != -1)
 		close(pmd->nlsk_fd);
-#endif
 	if (pmd->ka_fd != -1)
 		close(pmd->ka_fd);
-	if (pmd->ioctl_sock != -1)
-		close(pmd->ioctl_sock);
 	/* mac_addrs must not be freed alone because part of dev_private */
 	dev->data->mac_addrs = NULL;
 	rte_intr_instance_free(pmd->intr_handle);
diff --git a/drivers/net/tap/rte_eth_tap.h b/drivers/net/tap/rte_eth_tap.h
index ce4322ad046e..218ee1b811d8 100644
--- a/drivers/net/tap/rte_eth_tap.h
+++ b/drivers/net/tap/rte_eth_tap.h
@@ -73,13 +73,12 @@ struct pmd_internals {
 	int type;                         /* Type field - TUN|TAP */
 	int persist;			  /* 1 if keep link up, else 0 */
 	struct rte_ether_addr eth_addr;   /* Mac address of the device port */
-	struct ifreq remote_initial_flags;/* Remote netdevice flags on init */
+	unsigned int remote_initial_flags;/* Remote netdevice flags on init */
 	int remote_if_index;              /* remote netdevice IF_INDEX */
 	int if_index;                     /* IF_INDEX for the port */
-	int ioctl_sock;                   /* socket for ioctl calls */
+	int nlsk_fd;                      /* Netlink socket fd */
 
 #ifdef HAVE_TCA_FLOWER
-	int nlsk_fd;                      /* Netlink socket fd */
 	int flow_isolate;                 /* 1 if flow isolation is enabled */
 
 	struct tap_rss *rss;		  /* BPF program */
diff --git a/drivers/net/tap/tap_netlink.c b/drivers/net/tap/tap_netlink.c
index 5ff60f41d426..0682ba87e0da 100644
--- a/drivers/net/tap/tap_netlink.c
+++ b/drivers/net/tap/tap_netlink.c
@@ -6,6 +6,7 @@
 #include <errno.h>
 #include <inttypes.h>
 #include <linux/netlink.h>
+#include <net/if.h>
 #include <string.h>
 #include <sys/socket.h>
 #include <unistd.h>
@@ -411,3 +412,293 @@ tap_nlattr_nested_finish(struct tap_nlmsg *msg)
 
 	rte_free(tail);
 }
+
+/**
+ * Helper structure to pass data between netlink request and callback
+ */
+struct link_info_ctx {
+	struct ifinfomsg *info;
+	struct rte_ether_addr *mac;
+	unsigned int *flags;
+	unsigned int ifindex;
+	int found;
+};
+
+/**
+ * Callback to extract link information from RTM_GETLINK response
+ */
+static int
+tap_nl_link_cb(struct nlmsghdr *nh, void *arg)
+{
+	struct link_info_ctx *ctx = arg;
+	struct ifinfomsg *ifi = NLMSG_DATA(nh);
+	struct rtattr *rta;
+	int rta_len;
+
+	if (nh->nlmsg_type != RTM_NEWLINK)
+		return 0;
+
+	/* Check if this is the interface we're looking for */
+	if (ifi->ifi_index != (int)ctx->ifindex)
+		return 0;
+
+	ctx->found = 1;
+
+	/* Copy basic info if requested */
+	if (ctx->info)
+		*ctx->info = *ifi;
+
+	/* Extract flags if requested */
+	if (ctx->flags)
+		*ctx->flags = ifi->ifi_flags;
+
+	/* Parse attributes for MAC address if requested */
+	if (ctx->mac) {
+		rta = IFLA_RTA(ifi);
+		rta_len = IFLA_PAYLOAD(nh);
+
+		for (; RTA_OK(rta, rta_len); rta = RTA_NEXT(rta, rta_len)) {
+			if (rta->rta_type == IFLA_ADDRESS) {
+				if (RTA_PAYLOAD(rta) >= RTE_ETHER_ADDR_LEN)
+					memcpy(ctx->mac, RTA_DATA(rta),
+					       RTE_ETHER_ADDR_LEN);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Get interface flags by ifindex
+ *
+ * @param nlsk_fd
+ *   Netlink socket file descriptor
+ * @param ifindex
+ *   Interface index
+ * @param flags
+ *   Pointer to store interface flags
+ *
+ * @return
+ *   0 on success, -1 on error
+ */
+int
+tap_nl_get_flags(int nlsk_fd, unsigned int ifindex, unsigned int *flags)
+{
+	struct {
+		struct nlmsghdr nh;
+		struct ifinfomsg ifi;
+	} req = {
+		.nh = {
+			.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+			.nlmsg_type = RTM_GETLINK,
+			.nlmsg_flags = NLM_F_REQUEST,
+		},
+		.ifi = {
+			.ifi_family = AF_UNSPEC,
+			.ifi_index = ifindex,
+		},
+	};
+	struct link_info_ctx ctx = {
+		.flags = flags,
+		.ifindex = ifindex,
+		.found = 0,
+	};
+
+	if (tap_nl_send(nlsk_fd, &req.nh) < 0)
+		return -1;
+
+	if (tap_nl_recv(nlsk_fd, tap_nl_link_cb, &ctx) < 0)
+		return -1;
+
+	if (!ctx.found) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Set interface flags by ifindex
+ *
+ * @param nlsk_fd
+ *   Netlink socket file descriptor
+ * @param ifindex
+ *   Interface index
+ * @param flags
+ *   Flags to set/unset
+ * @param set
+ *   1 to set flags, 0 to unset them
+ *
+ * @return
+ *   0 on success, -1 on error
+ */
+int
+tap_nl_set_flags(int nlsk_fd, unsigned int ifindex, unsigned int flags, int set)
+{
+	struct {
+		struct nlmsghdr nh;
+		struct ifinfomsg ifi;
+	} req = {
+		.nh = {
+			.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+			.nlmsg_type = RTM_SETLINK,
+			.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
+		},
+		.ifi = {
+			.ifi_family = AF_UNSPEC,
+			.ifi_index = ifindex,
+			.ifi_flags = set ? flags : 0,
+			.ifi_change = flags,  /* mask of flags to change */
+		},
+	};
+
+	if (tap_nl_send(nlsk_fd, &req.nh) < 0)
+		return -1;
+
+	return tap_nl_recv_ack(nlsk_fd);
+}
+
+/**
+ * Set interface MTU by ifindex
+ *
+ * @param nlsk_fd
+ *   Netlink socket file descriptor
+ * @param ifindex
+ *   Interface index
+ * @param mtu
+ *   New MTU value
+ *
+ * @return
+ *   0 on success, -1 on error
+ */
+int
+tap_nl_set_mtu(int nlsk_fd, unsigned int ifindex, unsigned int mtu)
+{
+	struct {
+		struct nlmsghdr nh;
+		struct ifinfomsg ifi;
+		char buf[64];
+	} req = {
+		.nh = {
+			.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+			.nlmsg_type = RTM_SETLINK,
+			.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
+		},
+		.ifi = {
+			.ifi_family = AF_UNSPEC,
+			.ifi_index = ifindex,
+		},
+	};
+	struct rtattr *rta;
+
+	/* Add MTU attribute */
+	rta = (struct rtattr *)((char *)&req + NLMSG_ALIGN(req.nh.nlmsg_len));
+	rta->rta_type = IFLA_MTU;
+	rta->rta_len = RTA_LENGTH(sizeof(mtu));
+	memcpy(RTA_DATA(rta), &mtu, sizeof(mtu));
+	req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) + RTA_ALIGN(rta->rta_len);
+
+	if (tap_nl_send(nlsk_fd, &req.nh) < 0)
+		return -1;
+
+	return tap_nl_recv_ack(nlsk_fd);
+}
+
+/**
+ * Get interface MAC address by ifindex
+ *
+ * @param nlsk_fd
+ *   Netlink socket file descriptor
+ * @param ifindex
+ *   Interface index
+ * @param mac
+ *   Pointer to store MAC address
+ *
+ * @return
+ *   0 on success, -1 on error
+ */
+int
+tap_nl_get_mac(int nlsk_fd, unsigned int ifindex, struct rte_ether_addr *mac)
+{
+	struct {
+		struct nlmsghdr nh;
+		struct ifinfomsg ifi;
+	} req = {
+		.nh = {
+			.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+			.nlmsg_type = RTM_GETLINK,
+			.nlmsg_flags = NLM_F_REQUEST,
+		},
+		.ifi = {
+			.ifi_family = AF_UNSPEC,
+			.ifi_index = ifindex,
+		},
+	};
+	struct link_info_ctx ctx = {
+		.mac = mac,
+		.ifindex = ifindex,
+		.found = 0,
+	};
+
+	if (tap_nl_send(nlsk_fd, &req.nh) < 0)
+		return -1;
+
+	if (tap_nl_recv(nlsk_fd, tap_nl_link_cb, &ctx) < 0)
+		return -1;
+
+	if (!ctx.found) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Set interface MAC address by ifindex
+ *
+ * @param nlsk_fd
+ *   Netlink socket file descriptor
+ * @param ifindex
+ *   Interface index
+ * @param mac
+ *   New MAC address
+ *
+ * @return
+ *   0 on success, -1 on error
+ */
+int
+tap_nl_set_mac(int nlsk_fd, unsigned int ifindex, const struct rte_ether_addr *mac)
+{
+	struct {
+		struct nlmsghdr nh;
+		struct ifinfomsg ifi;
+		char buf[64];
+	} req = {
+		.nh = {
+			.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
+			.nlmsg_type = RTM_SETLINK,
+			.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
+		},
+		.ifi = {
+			.ifi_family = AF_UNSPEC,
+			.ifi_index = ifindex,
+		},
+	};
+	struct rtattr *rta;
+
+	/* Add MAC address attribute */
+	rta = (struct rtattr *)((char *)&req + NLMSG_ALIGN(req.nh.nlmsg_len));
+	rta->rta_type = IFLA_ADDRESS;
+	rta->rta_len = RTA_LENGTH(RTE_ETHER_ADDR_LEN);
+	memcpy(RTA_DATA(rta), mac, RTE_ETHER_ADDR_LEN);
+	req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) + RTA_ALIGN(rta->rta_len);
+
+	if (tap_nl_send(nlsk_fd, &req.nh) < 0)
+		return -1;
+
+	return tap_nl_recv_ack(nlsk_fd);
+}
diff --git a/drivers/net/tap/tap_netlink.h b/drivers/net/tap/tap_netlink.h
index 5eff6edbb1cd..b85be166245e 100644
--- a/drivers/net/tap/tap_netlink.h
+++ b/drivers/net/tap/tap_netlink.h
@@ -6,12 +6,11 @@
 #ifndef _TAP_NETLINK_H_
 #define _TAP_NETLINK_H_
 
-#include <ctype.h>
 #include <inttypes.h>
 #include <linux/rtnetlink.h>
 #include <linux/netlink.h>
-#include <stdio.h>
 
+#include <rte_ether.h>
 #include <rte_log.h>
 
 #define NLMSG_BUF 512
@@ -39,4 +38,11 @@ void tap_nlattr_add32(struct tap_nlmsg *msg, unsigned short type, uint32_t data)
 int tap_nlattr_nested_start(struct tap_nlmsg *msg, uint16_t type);
 void tap_nlattr_nested_finish(struct tap_nlmsg *msg);
 
+/* Link management functions using netlink */
+int tap_nl_get_flags(int nlsk_fd, unsigned int ifindex, unsigned int *flags);
+int tap_nl_set_flags(int nlsk_fd, unsigned int ifindex, unsigned int flags, int set);
+int tap_nl_set_mtu(int nlsk_fd, unsigned int ifindex, unsigned int mtu);
+int tap_nl_set_mac(int nlsk_fd, unsigned int ifindex, const struct rte_ether_addr *mac);
+int tap_nl_get_mac(int nlsk_fd, unsigned int ifindex, struct rte_ether_addr *mac);
+
 #endif /* _TAP_NETLINK_H_ */
