From bbd8fdf42efc993be3371e4a4c4c9545961cc47e Mon Sep 17 00:00:00 2001
From: Maxime Leroy <maxime@leroys.fr>
Date: Fri, 5 Sep 2025 11:23:27 +0200
Subject: [PATCH 4/4] (WIP) zebra: get interface speed from dataplane via
 ethtool

This introduces DPLANE_OP_INTF_SPEED so link speed is resolved in the
dataplane via ethtool and reported to zebra. Zebra no longer performs
synchronous speed reads; it simply applies the value provided by the
dataplane.

If speed is already known during interface creation or modification, it
can be included in INTF_INSTALL/INTF_UPDATE; the zebra main thread also
issues a follow-up INTF_SPEED to request the dataplane to fetch the
speed asynchronously.

For dataplane providers that implement only INTF_INSTALL/INTF_UPDATE and
do not support INTF_SPEED, zebra uses the speed provided by those
install/update ops, attempts a single INTF_SPEED query, and stops on
failure.

Note:

1) dplane_intf_speed reuse dplane_ctx_intf_init to init intf fields.
Probably not the right way to do that, should be use
dplane_intf_update_internal(ifp, DPLANE_OP_INTF_SPEED) or create own
dplane ctx with the miminal fields needed to query speed ?

2) Same for dplane stats, should we increments stats ? own stats or reuse
dg_intfs/errors stats from INTF_INSTALL/UPDATE/DELETE ?

Signed-off-by: Maxime Leroy <maxime@leroys.fr>
---
 zebra/if_netlink.c     |  2 ++
 zebra/interface.c      | 79 +++++++++++++++++++++++++++++++++++++-----
 zebra/interface.h      |  1 +
 zebra/kernel_netlink.c |  1 +
 zebra/zebra_dplane.c   | 48 +++++++++++++++++++++++++
 zebra/zebra_dplane.h   |  2 ++
 zebra/zebra_rib.c      |  1 +
 7 files changed, 126 insertions(+), 8 deletions(-)

diff --git a/zebra/if_netlink.c b/zebra/if_netlink.c
index c8ee99f..b1e1411 100644
--- a/zebra/if_netlink.c
+++ b/zebra/if_netlink.c
@@ -1408,6 +1408,8 @@ int netlink_link_change(struct nlmsghdr *h, ns_id_t ns_id, int startup)
 			} else
 				zif_slave_type = ZEBRA_IF_SLAVE_OTHER;
 		}
+		dplane_ctx_set_ifp_speed(ctx, get_iflink_speed(vrf_id, name, NULL));
+		dplane_ctx_set_ifp_speed_set(ctx, true);
 		dplane_ctx_set_ifp_zif_slave_type(ctx, zif_slave_type);
 		dplane_ctx_set_ifp_vrf_id(ctx, vrf_id);
 		dplane_ctx_set_ifp_master_ifindex(ctx, master_infindex);
diff --git a/zebra/interface.c b/zebra/interface.c
index 16e762b..d96bc83 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -64,20 +64,31 @@ static const char *if_zebra_data_state(uint8_t state)
 static void if_zebra_speed_update(struct event *thread)
 {
 	struct interface *ifp = EVENT_ARG(thread);
-	struct zebra_if *zif = ifp->info;
+	dplane_intf_speed(ifp);
+}
+
+static void zebra_if_speed_update_ctx(struct zebra_dplane_ctx *ctx,
+				      struct interface *ifp)
+{
+	enum zebra_dplane_result dp_res;
+	struct zebra_if *zif;
+	bool speed_set, changed = false;
 	uint32_t new_speed;
-	bool changed = false;
-	int error = 0;
 
-	new_speed = kernel_get_speed(ifp, &error);
+	if (!ifp)
+		return;
+	zif = ifp->info;
 
+	dp_res = dplane_ctx_get_status(ctx);
 	/* error may indicate vrf not available or
 	 * interfaces not available.
 	 * note that loopback & virtual interfaces can return 0 as speed
 	 */
-	if (error == INTERFACE_SPEED_ERROR_READ)
+	if (dp_res == ZEBRA_DPLANE_REQUEST_FAILURE)
 		return;
 
+	speed_set = dplane_ctx_get_ifp_speed_set(ctx);
+	new_speed = speed_set ? dplane_ctx_get_ifp_speed(ctx) : 0;
 	if (new_speed != ifp->speed) {
 		zlog_info("%s: %s old speed: %u new speed: %u", __func__,
 			  ifp->name, ifp->speed, new_speed);
@@ -86,7 +97,7 @@ static void if_zebra_speed_update(struct event *thread)
 		changed = true;
 	}
 
-	if (changed || error == INTERFACE_SPEED_ERROR_UNKNOWN) {
+	if (changed || !speed_set) {
 #define SPEED_UPDATE_SLEEP_TIME 5
 #define SPEED_UPDATE_COUNT_MAX (4 * 60 / SPEED_UPDATE_SLEEP_TIME)
 		/*
@@ -101,7 +112,7 @@ static void if_zebra_speed_update(struct event *thread)
 		 * to not update the system to keep track of that.  This
 		 * is far simpler to just stop trying after 4 minutes
 		 */
-		if (error == INTERFACE_SPEED_ERROR_UNKNOWN &&
+		if (!speed_set &&
 		    zif->speed_update_count == SPEED_UPDATE_COUNT_MAX)
 			return;
 
@@ -112,6 +123,56 @@ static void if_zebra_speed_update(struct event *thread)
 	}
 }
 
+void zebra_if_speed_process(struct zebra_dplane_ctx *ctx)
+{
+	const char *name = dplane_ctx_get_ifname(ctx);
+	ns_id_t ns_id = dplane_ctx_get_ns_id(ctx);
+	struct interface *ifp;
+	struct zebra_ns *zns;
+	uint32_t speed;
+	int error;
+
+	dplane_ctx_set_status(ctx, ZEBRA_DPLANE_REQUEST_FAILURE);
+
+	zns = zebra_ns_lookup(ns_id);
+	if (!zns) {
+		zlog_err("Where is our namespace?");
+		goto err;
+	}
+
+	ifp = if_lookup_by_name_per_ns(zns, name);
+	if (ifp == NULL) {
+		ifindex_t ifindex = dplane_ctx_get_ifindex(ctx);
+
+		zlog_err("Get LINK SPEED received for unknown interface %s(%u)",
+			 name, ifindex);
+		goto err;
+	}
+
+	speed = kernel_get_speed(ifp, &error);
+	switch (error) {
+	case 0:
+		dplane_ctx_set_status(ctx, ZEBRA_DPLANE_REQUEST_SUCCESS);
+		dplane_ctx_set_ifp_speed(ctx, speed);
+		dplane_ctx_set_ifp_speed_set(ctx, true);
+		return;
+	case INTERFACE_SPEED_ERROR_UNKNOWN:
+		dplane_ctx_set_status(ctx, ZEBRA_DPLANE_REQUEST_SUCCESS);
+		dplane_ctx_set_ifp_speed_set(ctx, false);
+		return;
+	case INTERFACE_SPEED_ERROR_READ:
+		/* INTERFACE_SPEED_ERROR_READ: means no device, no vrf */
+		break;
+	default:
+		if (IS_ZEBRA_DEBUG_KERNEL)
+			zlog_debug("kernel_get_speed returns an unkwnown error %u\n", error);
+		break;
+	}
+
+err:
+	dplane_ctx_set_status(ctx, ZEBRA_DPLANE_REQUEST_FAILURE);
+}
+
 static void zebra_if_node_destroy(route_table_delegate_t *delegate,
 				  struct route_table *table,
 				  struct route_node *node)
@@ -1992,7 +2053,7 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 			if_update_state_mtu6(ifp, mtu);
 			if_update_state_metric(ifp, 0);
 			if (!speed_set)
-				speed = kernel_get_speed(ifp, NULL);
+				speed = 0;
 			if_update_state_speed(ifp, speed);
 			ifp->ptm_status = ZEBRA_PTM_STATUS_UNKNOWN;
 			ifp->txqlen = dplane_ctx_get_intf_txqlen(ctx);
@@ -2248,6 +2309,8 @@ void zebra_if_dplane_result(struct zebra_dplane_ctx *ctx)
 			zebra_if_update_ctx(ctx, ifp);
 	} else if (op == DPLANE_OP_INTF_NETCONFIG) {
 		zebra_if_netconf_update_ctx(ctx, ifp, ifindex);
+	} else if (op == DPLANE_OP_INTF_SPEED) {
+		zebra_if_speed_update_ctx(ctx, ifp);
 	}
 }
 
diff --git a/zebra/interface.h b/zebra/interface.h
index 0947a22..a5af669 100644
--- a/zebra/interface.h
+++ b/zebra/interface.h
@@ -348,6 +348,7 @@ extern void zebra_l2_unmap_slave_from_bond(struct zebra_if *zif);
 extern const char *zebra_protodown_rc_str(uint32_t protodown_rc, char *pd_buf,
 					  uint32_t pd_buf_len);
 void zebra_if_dplane_result(struct zebra_dplane_ctx *ctx);
+void zebra_if_speed_process(struct zebra_dplane_ctx *ctx);
 
 #ifdef HAVE_PROC_NET_DEV
 extern void ifstat_update_proc(void);
diff --git a/zebra/kernel_netlink.c b/zebra/kernel_netlink.c
index 4c239f0..79ca1b1 100644
--- a/zebra/kernel_netlink.c
+++ b/zebra/kernel_netlink.c
@@ -1614,6 +1614,7 @@ static enum netlink_msg_status nl_put_msg(struct nl_batch *bth,
 	case DPLANE_OP_BR_PORT_UPDATE:
 		return FRR_NETLINK_SUCCESS;
 
+	case DPLANE_OP_INTF_SPEED:
 	case DPLANE_OP_IPTABLE_ADD:
 	case DPLANE_OP_IPTABLE_DELETE:
 	case DPLANE_OP_IPSET_ADD:
diff --git a/zebra/zebra_dplane.c b/zebra/zebra_dplane.c
index 8a76c9a..ec9617d 100644
--- a/zebra/zebra_dplane.c
+++ b/zebra/zebra_dplane.c
@@ -901,6 +901,7 @@ static void dplane_ctx_free_internal(struct zebra_dplane_ctx *ctx)
 		break;
 	case DPLANE_OP_GRE_SET:
 	case DPLANE_OP_INTF_NETCONFIG:
+	case DPLANE_OP_INTF_SPEED:
 	case DPLANE_OP_STARTUP_STAGE:
 	case DPLANE_OP_SRV6_ENCAP_SRCADDR_SET:
 		break;
@@ -1167,6 +1168,9 @@ const char *dplane_op2str(enum dplane_op_e op)
 	case DPLANE_OP_INTF_DELETE:
 		return "INTF_DELETE";
 
+	case DPLANE_OP_INTF_SPEED:
+		return "INTF_SPEED";
+
 	case DPLANE_OP_TC_QDISC_INSTALL:
 		return "TC_QDISC_INSTALL";
 	case DPLANE_OP_TC_QDISC_UNINSTALL:
@@ -5283,6 +5287,32 @@ enum zebra_dplane_result dplane_intf_update(const struct interface *ifp)
 	return ret;
 }
 
+/*
+ * Enqueue a interface speed query for the dataplane.
+ */
+enum zebra_dplane_result dplane_intf_speed(const struct interface *ifp)
+{
+	enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
+	struct zebra_dplane_ctx *ctx = NULL;
+	int ret;
+
+	ctx = dplane_ctx_alloc();
+	/* set useless fields for speed like protodwn .., to fix ?
+	 * Calling intf_update_internal will update .dg_intfs_in/errors,
+	 * should we have dedicated stats ?
+	 */
+	ret = dplane_ctx_intf_init(ctx, DPLANE_OP_INTF_SPEED, ifp);
+	if (ret == AOK)
+		ret = dplane_update_enqueue(ctx);
+
+	if (ret == AOK)
+		result = ZEBRA_DPLANE_REQUEST_QUEUED;
+	else if (ctx)
+		dplane_ctx_free(&ctx);
+
+	return result;
+}
+
 /*
  * Enqueue vxlan/evpn mac add (or update).
  */
@@ -6797,6 +6827,13 @@ static void kernel_dplane_log_detail(struct zebra_dplane_ctx *ctx)
 			   dplane_ctx_get_ifindex(ctx),
 			   dplane_ctx_intf_is_protodown(ctx));
 		break;
+	case DPLANE_OP_INTF_SPEED:
+		zlog_debug("Dplane intf %s, idx %u, speed %u",
+			   dplane_op2str(dplane_ctx_get_op(ctx)),
+			   dplane_ctx_get_ifindex(ctx),
+			   dplane_ctx_get_ifp_speed(ctx));
+		break;
+
 
 	/* TODO: more detailed log */
 	case DPLANE_OP_TC_QDISC_INSTALL:
@@ -6993,6 +7030,7 @@ static void kernel_dplane_handle_result(struct zebra_dplane_ctx *ctx)
 	case DPLANE_OP_INTF_ADDR_ADD:
 	case DPLANE_OP_INTF_ADDR_DEL:
 	case DPLANE_OP_INTF_NETCONFIG:
+	case DPLANE_OP_INTF_SPEED:
 	case DPLANE_OP_VLAN_INSTALL:
 		break;
 
@@ -7034,6 +7072,14 @@ kernel_dplane_process_ipset_entry(struct zebra_dplane_provider *prov,
 	dplane_provider_enqueue_out_ctx(prov, ctx);
 }
 
+static void
+kernel_dplane_process_if_speed(struct zebra_dplane_provider *prov,
+			       struct zebra_dplane_ctx *ctx)
+{
+	zebra_if_speed_process(ctx);
+	dplane_provider_enqueue_out_ctx(prov, ctx);
+}
+
 /*
  * Kernel provider callback
  */
@@ -7068,6 +7114,8 @@ static int kernel_dplane_process_func(struct zebra_dplane_provider *prov)
 			  || dplane_ctx_get_op(ctx)
 				     == DPLANE_OP_IPSET_ENTRY_DELETE))
 			kernel_dplane_process_ipset_entry(prov, ctx);
+		else if (dplane_ctx_get_op(ctx) == DPLANE_OP_INTF_SPEED)
+			kernel_dplane_process_if_speed(prov, ctx);
 		else
 			dplane_ctx_list_add_tail(&work_list, ctx);
 	}
diff --git a/zebra/zebra_dplane.h b/zebra/zebra_dplane.h
index 058cf75..35a0728 100644
--- a/zebra/zebra_dplane.h
+++ b/zebra/zebra_dplane.h
@@ -190,6 +190,7 @@ enum dplane_op_e {
 
 	/* Incoming interface config events */
 	DPLANE_OP_INTF_NETCONFIG,
+	DPLANE_OP_INTF_SPEED,
 
 	/* Interface update */
 	DPLANE_OP_INTF_INSTALL,
@@ -927,6 +928,7 @@ enum zebra_dplane_result dplane_intf_addr_unset(const struct interface *ifp,
  */
 enum zebra_dplane_result dplane_intf_add(const struct interface *ifp);
 enum zebra_dplane_result dplane_intf_update(const struct interface *ifp);
+enum zebra_dplane_result dplane_intf_speed(const struct interface *ifp);
 
 /*
  * Enqueue tc link changes for the dataplane.
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index 0d5bd2e..b469184 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -5239,6 +5239,7 @@ static void rib_process_dplane_results(struct event *thread)
 			case DPLANE_OP_INTF_UPDATE:
 			case DPLANE_OP_INTF_DELETE:
 			case DPLANE_OP_INTF_NETCONFIG:
+			case DPLANE_OP_INTF_SPEED:
 				zebra_if_dplane_result(ctx);
 				break;
 
-- 
2.43.0

