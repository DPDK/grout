From adaa85be78e69e92bd2cc46f8c41462edd16c541 Mon Sep 17 00:00:00 2001
From: Maxime Leroy <maxime@leroys.fr>
Date: Mon, 22 Dec 2025 14:28:32 +0100
Subject: [PATCH 1/2] zebra: do not rely on dplane table_id for VRF delete

zebra_if_dplane_ifp_handling() was reading dplane_ctx_get_ifp_table_id()
for VRF events.

In the netlink dplane backend, ifp_table_id is only set via
netlink_vrf_change(), which is invoked from netlink_link_change() for
RTM_NEWLINK VRF events. It is not set for RTM_DELLINK.

The VRF delete path does not require table_id and should not depend
on a dplane field that is unset for delete operations.

Split VRF handling into interface_vrf_update() and interface_vrf_del()
so:
- add/update uses the dplane-provided table_id
- delete only relies on the VRF identity

Signed-off-by: Maxime Leroy <maxime@leroys.fr>
---
 zebra/interface.c | 137 +++++++++++++++++++++++-----------------------
 1 file changed, 67 insertions(+), 70 deletions(-)

diff --git a/zebra/interface.c b/zebra/interface.c
index 52c2619eed..17b62cf586 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -1425,86 +1425,81 @@ static void zebra_if_netconf_update_ctx(struct zebra_dplane_ctx *ctx,
 			(*linkdown_set ? "ON" : "OFF"));
 }
 
-static void interface_vrf_change(enum dplane_op_e op, ifindex_t ifindex,
-				 const char *name, uint32_t tableid,
-				 ns_id_t ns_id)
+static void interface_vrf_del(ifindex_t ifindex, const char *name)
 {
 	struct vrf *vrf;
-	struct zebra_vrf *zvrf = NULL;
 
-	if (op == DPLANE_OP_INTF_DELETE) {
-		if (IS_ZEBRA_DEBUG_DPLANE)
-			zlog_debug("DPLANE_OP_INTF_DELETE for VRF %s(%u)", name,
-				   ifindex);
+	if (IS_ZEBRA_DEBUG_DPLANE)
+		zlog_debug("DPLANE_OP_INTF_DELETE for VRF %s(%u)", name, ifindex);
 
-		vrf = vrf_lookup_by_id((vrf_id_t)ifindex);
-		if (!vrf) {
-			flog_warn(EC_ZEBRA_VRF_NOT_FOUND,
-				  "%s(%u): vrf not found", name, ifindex);
-			return;
-		}
+	vrf = vrf_lookup_by_id((vrf_id_t)ifindex);
+	if (!vrf) {
+		flog_warn(EC_ZEBRA_VRF_NOT_FOUND, "%s(%u): vrf not found", name, ifindex);
+		return;
+	}
 
-		vrf_delete(vrf);
-	} else {
-		if (IS_ZEBRA_DEBUG_DPLANE)
-			zlog_debug(
-				"DPLANE_OP_INTF_UPDATE for VRF %s(%u) table %u",
-				name, ifindex, tableid);
+	vrf_delete(vrf);
+}
 
-		/*
-		 * For a given tableid, if there already exists a vrf and it
-		 * is different from the current vrf to be operated, then there
-		 * is a misconfiguration and zebra will exit.
-		 */
-		vrf_id_t exist_id = zebra_vrf_lookup_by_table(tableid, ns_id);
 
-		if (exist_id != VRF_DEFAULT || strmatch(name, VRF_DEFAULT_NAME)) {
-			vrf = vrf_lookup_by_id(exist_id);
+static void interface_vrf_update(ifindex_t ifindex, const char *name, uint32_t tableid,
+				 ns_id_t ns_id)
+{
+	struct vrf *vrf;
+	struct zebra_vrf *zvrf = NULL;
 
-			if (!vrf_lookup_by_id((vrf_id_t)ifindex) && !vrf) {
-				flog_err(EC_ZEBRA_VRF_NOT_FOUND,
-					 "VRF %s id %u does not exist", name,
-					 ifindex);
-				frr_exit_with_buffer_flush(-1);
-			}
+	if (IS_ZEBRA_DEBUG_DPLANE)
+		zlog_debug("DPLANE_OP_INTF_UPDATE for VRF %s(%u) table %u", name, ifindex, tableid);
 
-			if (vrf && strcmp(name, vrf->name)) {
-				flog_err(EC_ZEBRA_VRF_MISCONFIGURED,
-					 "VRF %s id %u table id overlaps existing vrf %s(%d), misconfiguration exiting",
-					 name, ifindex, vrf->name, vrf->vrf_id);
-				frr_exit_with_buffer_flush(-1);
-			}
+	/*
+	 * For a given tableid, if there already exists a vrf and it
+	 * is different from the current vrf to be operated, then there
+	 * is a misconfiguration and zebra will exit.
+	 */
+	vrf_id_t exist_id = zebra_vrf_lookup_by_table(tableid, ns_id);
+
+	if (exist_id != VRF_DEFAULT || strmatch(name, VRF_DEFAULT_NAME)) {
+		vrf = vrf_lookup_by_id(exist_id);
+
+		if (!vrf_lookup_by_id((vrf_id_t)ifindex) && !vrf) {
+			flog_err(EC_ZEBRA_VRF_NOT_FOUND, "VRF %s id %u does not exist", name,
+				 ifindex);
+			frr_exit_with_buffer_flush(-1);
 		}
 
-		vrf = vrf_update((vrf_id_t)ifindex, name);
-		if (!vrf) {
-			flog_err(EC_LIB_INTERFACE, "VRF %s id %u not created",
-				 name, ifindex);
-			return;
+		if (vrf && strcmp(name, vrf->name)) {
+			flog_err(EC_ZEBRA_VRF_MISCONFIGURED,
+				 "VRF %s id %u table id overlaps existing vrf %s(%d), misconfiguration exiting",
+				 name, ifindex, vrf->name, vrf->vrf_id);
+			frr_exit_with_buffer_flush(-1);
 		}
+	}
 
-		/*
-		 * This is the only place that we get the actual kernel table_id
-		 * being used.  We need it to set the table_id of the routes
-		 * we are passing to the kernel.... And to throw some totally
-		 * awesome parties. that too.
-		 *
-		 * At this point we *must* have a zvrf because the vrf_create
-		 * callback creates one.  We *must* set the table id
-		 * before the vrf_enable because of( at the very least )
-		 * static routes being delayed for installation until
-		 * during the vrf_enable callbacks.
-		 */
-		zvrf = (struct zebra_vrf *)vrf->info;
-		zvrf->table_id = tableid;
+	vrf = vrf_update((vrf_id_t)ifindex, name);
+	if (!vrf) {
+		flog_err(EC_LIB_INTERFACE, "VRF %s id %u not created", name, ifindex);
+		return;
+	}
 
-		/* Enable the created VRF. */
-		if (!vrf_enable(vrf)) {
-			flog_err(EC_LIB_INTERFACE,
-				 "Failed to enable VRF %s id %u", name,
-				 ifindex);
-			return;
-		}
+	/*
+	 * This is the only place that we get the actual kernel table_id
+	 * being used.  We need it to set the table_id of the routes
+	 * we are passing to the kernel.... And to throw some totally
+	 * awesome parties. that too.
+	 *
+	 * At this point we *must* have a zvrf because the vrf_create
+	 * callback creates one.  We *must* set the table id
+	 * before the vrf_enable because of( at the very least )
+	 * static routes being delayed for installation until
+	 * during the vrf_enable callbacks.
+	 */
+	zvrf = (struct zebra_vrf *)vrf->info;
+	zvrf->table_id = tableid;
+
+	/* Enable the created VRF. */
+	if (!vrf_enable(vrf)) {
+		flog_err(EC_LIB_INTERFACE, "Failed to enable VRF %s id %u", name, ifindex);
+		return;
 	}
 }
 
@@ -1876,7 +1871,6 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 	ns_id_t ns_id = dplane_ctx_get_ns_id(ctx);
 	ifindex_t ifindex = dplane_ctx_get_ifindex(ctx);
 	ifindex_t bond_ifindex = dplane_ctx_get_ifp_bond_ifindex(ctx);
-	uint32_t tableid = dplane_ctx_get_ifp_table_id(ctx);
 	enum zebra_iftype zif_type = dplane_ctx_get_ifp_zif_type(ctx);
 	struct interface *ifp;
 	struct zebra_ns *zns;
@@ -1914,7 +1908,7 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 		if_delete_update(&ifp);
 
 		if (zif_type == ZEBRA_IF_VRF && !vrf_is_backend_netns())
-			interface_vrf_change(op, ifindex, name, tableid, ns_id);
+			interface_vrf_del(ifindex, name);
 	} else {
 		ifindex_t master_ifindex, bridge_ifindex, link_ifindex;
 		enum zebra_slave_iftype zif_slave_type;
@@ -1931,8 +1925,11 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 		uint8_t family;
 
 		/* If VRF, create or update the VRF structure itself. */
-		if (zif_type == ZEBRA_IF_VRF && !vrf_is_backend_netns())
-			interface_vrf_change(op, ifindex, name, tableid, ns_id);
+		if (zif_type == ZEBRA_IF_VRF && !vrf_is_backend_netns()) {
+			uint32_t tableid = dplane_ctx_get_ifp_table_id(ctx);
+
+			interface_vrf_update(ifindex, name, tableid, ns_id);
+		}
 
 		master_ifindex = dplane_ctx_get_ifp_master_ifindex(ctx);
 		zif_slave_type = dplane_ctx_get_ifp_zif_slave_type(ctx);
-- 
2.43.0

