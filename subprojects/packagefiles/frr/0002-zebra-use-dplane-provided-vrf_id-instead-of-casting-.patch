From 1cc366a1a709f9cb58d5374888b49d4ed87b09da Mon Sep 17 00:00:00 2001
From: Maxime Leroy <maxime@leroys.fr>
Date: Mon, 22 Dec 2025 15:02:41 +0100
Subject: [PATCH 2/2] zebra: use dplane-provided vrf_id instead of casting
 ifindex

interface_vrf_change() was implicitly assuming that the VRF netdevice
ifindex could be used as zebra's vrf_id.

This assumption holds true for the Linux kernel dataplane, where the VRF
ID is defined as the ifindex of the VRF interface, so this change does
not alter kernel behavior.

However, the dataplane API already exposes both concepts explicitly via
dplane_ctx_get_ifindex() and dplane_ctx_get_ifp_vrf_id(ctx). Using the
proper accessor avoids casting an ifindex to vrf_id_t and better respects
the dataplane abstraction.

On interface updates, the vrf_id provided by the dataplane is now used
directly. On interface deletion (DELLINK), where the dataplane context
may no longer carry vrf information, zebra relies on the existing ifp
state keyed by ifindex.

This is required for non-kernel dataplanes such as Grout (DPDK), where
the VRF ID is not equal to the VRF interface ifindex. In that case, using
the correct vrf_id fixes VRF handling between zebra and the Grout
dataplane.

Signed-off-by: Maxime Leroy <maxime@leroys.fr>
---
 zebra/interface.c | 34 +++++++++++++++++-----------------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/zebra/interface.c b/zebra/interface.c
index 17b62cf586..3c60d4e166 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -1425,16 +1425,16 @@ static void zebra_if_netconf_update_ctx(struct zebra_dplane_ctx *ctx,
 			(*linkdown_set ? "ON" : "OFF"));
 }
 
-static void interface_vrf_del(ifindex_t ifindex, const char *name)
+static void interface_vrf_del(vrf_id_t vrf_id, const char *name)
 {
 	struct vrf *vrf;
 
 	if (IS_ZEBRA_DEBUG_DPLANE)
-		zlog_debug("DPLANE_OP_INTF_DELETE for VRF %s(%u)", name, ifindex);
+		zlog_debug("DPLANE_OP_INTF_DELETE for VRF %s(%u)", name, vrf_id);
 
-	vrf = vrf_lookup_by_id((vrf_id_t)ifindex);
+	vrf = vrf_lookup_by_id(vrf_id);
 	if (!vrf) {
-		flog_warn(EC_ZEBRA_VRF_NOT_FOUND, "%s(%u): vrf not found", name, ifindex);
+		flog_warn(EC_ZEBRA_VRF_NOT_FOUND, "%s(%u): vrf not found", name, vrf_id);
 		return;
 	}
 
@@ -1442,14 +1442,13 @@ static void interface_vrf_del(ifindex_t ifindex, const char *name)
 }
 
 
-static void interface_vrf_update(ifindex_t ifindex, const char *name, uint32_t tableid,
-				 ns_id_t ns_id)
+static void interface_vrf_update(vrf_id_t vrf_id, const char *name, uint32_t tableid, ns_id_t ns_id)
 {
 	struct vrf *vrf;
 	struct zebra_vrf *zvrf = NULL;
 
 	if (IS_ZEBRA_DEBUG_DPLANE)
-		zlog_debug("DPLANE_OP_INTF_UPDATE for VRF %s(%u) table %u", name, ifindex, tableid);
+		zlog_debug("DPLANE_OP_INTF_UPDATE for VRF %s(%u) table %u", name, vrf_id, tableid);
 
 	/*
 	 * For a given tableid, if there already exists a vrf and it
@@ -1461,23 +1460,23 @@ static void interface_vrf_update(ifindex_t ifindex, const char *name, uint32_t t
 	if (exist_id != VRF_DEFAULT || strmatch(name, VRF_DEFAULT_NAME)) {
 		vrf = vrf_lookup_by_id(exist_id);
 
-		if (!vrf_lookup_by_id((vrf_id_t)ifindex) && !vrf) {
+		if (!vrf_lookup_by_id(vrf_id) && !vrf) {
 			flog_err(EC_ZEBRA_VRF_NOT_FOUND, "VRF %s id %u does not exist", name,
-				 ifindex);
+				 vrf_id);
 			frr_exit_with_buffer_flush(-1);
 		}
 
 		if (vrf && strcmp(name, vrf->name)) {
 			flog_err(EC_ZEBRA_VRF_MISCONFIGURED,
 				 "VRF %s id %u table id overlaps existing vrf %s(%d), misconfiguration exiting",
-				 name, ifindex, vrf->name, vrf->vrf_id);
+				 name, vrf_id, vrf->name, vrf->vrf_id);
 			frr_exit_with_buffer_flush(-1);
 		}
 	}
 
-	vrf = vrf_update((vrf_id_t)ifindex, name);
+	vrf = vrf_update(vrf_id, name);
 	if (!vrf) {
-		flog_err(EC_LIB_INTERFACE, "VRF %s id %u not created", name, ifindex);
+		flog_err(EC_LIB_INTERFACE, "VRF %s id %u not created", name, vrf_id);
 		return;
 	}
 
@@ -1498,7 +1497,7 @@ static void interface_vrf_update(ifindex_t ifindex, const char *name, uint32_t t
 
 	/* Enable the created VRF. */
 	if (!vrf_enable(vrf)) {
-		flog_err(EC_LIB_INTERFACE, "Failed to enable VRF %s id %u", name, ifindex);
+		flog_err(EC_LIB_INTERFACE, "Failed to enable VRF %s id %u", name, vrf_id);
 		return;
 	}
 }
@@ -1874,6 +1873,7 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 	enum zebra_iftype zif_type = dplane_ctx_get_ifp_zif_type(ctx);
 	struct interface *ifp;
 	struct zebra_ns *zns;
+	vrf_id_t vrf_id;
 
 	zns = zebra_ns_lookup(ns_id);
 	if (!zns) {
@@ -1905,16 +1905,16 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 		else if (IS_ZEBRA_IF_VXLAN(ifp))
 			zebra_l2_vxlanif_del(ifp);
 
+		vrf_id = ifp->vrf->vrf_id;
 		if_delete_update(&ifp);
 
 		if (zif_type == ZEBRA_IF_VRF && !vrf_is_backend_netns())
-			interface_vrf_del(ifindex, name);
+			interface_vrf_del(vrf_id, name);
 	} else {
 		ifindex_t master_ifindex, bridge_ifindex, link_ifindex;
 		enum zebra_slave_iftype zif_slave_type;
 		uint8_t bypass;
 		uint64_t flags;
-		vrf_id_t vrf_id;
 		uint32_t mtu;
 		ns_id_t link_nsid;
 		struct zebra_if *zif;
@@ -1925,10 +1925,11 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 		uint8_t family;
 
 		/* If VRF, create or update the VRF structure itself. */
+		vrf_id = dplane_ctx_get_ifp_vrf_id(ctx);
 		if (zif_type == ZEBRA_IF_VRF && !vrf_is_backend_netns()) {
 			uint32_t tableid = dplane_ctx_get_ifp_table_id(ctx);
 
-			interface_vrf_update(ifindex, name, tableid, ns_id);
+			interface_vrf_update(vrf_id, name, tableid, ns_id);
 		}
 
 		master_ifindex = dplane_ctx_get_ifp_master_ifindex(ctx);
@@ -1937,7 +1938,6 @@ static void zebra_if_dplane_ifp_handling(struct zebra_dplane_ctx *ctx)
 		bond_ifindex = dplane_ctx_get_ifp_bond_ifindex(ctx);
 		bypass = dplane_ctx_get_ifp_bypass(ctx);
 		flags = dplane_ctx_get_ifp_flags(ctx);
-		vrf_id = dplane_ctx_get_ifp_vrf_id(ctx);
 		mtu = dplane_ctx_get_ifp_mtu(ctx);
 		link_ifindex = dplane_ctx_get_ifp_link_ifindex(ctx);
 		link_nsid = dplane_ctx_get_ifp_link_nsid(ctx);
-- 
2.43.0

